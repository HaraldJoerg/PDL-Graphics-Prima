
=begin later

This is a bit of Postscript handling code which will eventually need to
be fleshed out. But that'll have to come later. Perhaps I will put the
postscript code in its own .pd file since it is fairly different from
the apricot-based code.

pp_def('prima_ps_polyline_stroke',
	Pars => 'int x(n); int y(n)',
	OtherPars => 'SV * stroke_sv',
	GenericTypes => ['L'],
	PMCode => q{
		sub Prima::PS::Drawable::pdl_polyline {
			my ($self, $x, $y) = @_;
			
			# Create the Perl scalar which I will fill with stroke commands
			my $to_stroke = '';
			
			# Construct the stroke:
			PDL::_prima_ps_polyline_stroke_int($x, $y, $to_stroke);
			
			# At this point, $to_stroke has been filled with postscript commands
			# for drawing the polyline. Finish by calling the stroke:
			$self->stroke('', $to_stroke, '');
		}
	},
	Code => q{
		int n_size, i;
		n_size = $SIZE(n);
		
		/* Run through the data and concatenate the PS commands to draw it. */
		threadloop %{
			/* Begin by moving to the first point. Prima defines the shorthands
			 * N for 'newpath' and M for 'move'
			 */
			sv_catpvf(stroke_sv, "N %f %f M ", $x(n=>0), $y(n=>0));
			
			/* Put the rest of the x-y data into the stroke string. Prima
			 * defines the shorthand l for 'lineto'
			 */
			for (i = 1; i < n_size; i++) {
				sv_catvfg(stroke_sv, "%f %f l ", $x(n=>i), $y(n=>i));
			}
			
			/* Finish the command by appending a capital O, which Prima defines
			 * as a shorthand for 'stroke'
			 */
			sv_catpv(stroke_sv, "O\n");
		%}
	},
	Doc => <<'EOD'


=head2 polyline

  Prima Signature: (widget; x(n); y(n))
  PDL Signatue: (x(n); y(n); widget)

=for ref

Draws a multi-segment line on a widget with the given x- and y-coordinates.

This is useful for making quick line-drawings on your 

=for example

 # Draw a sine curve on the widget:
 my $x = sequence(200);
 my $y = ( sin($x / 20) + 1 ) * 50;
 $widget->pdl_polyline($x, $y);

 =cut

EOD

);

=end later

=cut

