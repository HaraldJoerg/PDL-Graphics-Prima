use strict;
pp_addpm({At=>'Top'},<<'ModuleMaterial');

BEGIN { 
$VERSION = '1.00'; 
} 

use strict;
use warnings;
use PDL;
use Scalar::Util;	# needed for 'blessed'

# working here - use Exporter and set as 'EXPORT_OK' the functions
# pdl_of_patterns_for and pdl_of_handles_for. I need to write them, too.
# Their usage looks like this:
#  my $patters = pdl_of_patterns_for($pat1, $pat2, ...);
#  my $handles = pdl_of_handles_for($widget1, $widget2, ...);

=head1 NAME

PDL::Graphics::Prima - PDL-aware drawing functions for Prima widgets

=head1 SYNOPSIS

 # working here - make a useful synopsis

=head1 DESCRIPTION

working here - write this

=head2 Line patterns

It may happen that you want to draw a number of different lines, each with a
different line patter. There is a slight subtlety in how you do this.

Use byte arrays (or it will be cast to a byte array for you). All of the
patterns must have the same number of bytes in their specification, but there's
a decent chance that those specifications are different lenghts. In that case,
simply pad the shorter specifications with zeroes.

=head1 CONSIDERATIONS

The Prima image coordinate origin is located in lower left corner, which is
where you would expect to find it when creating plots. However, it is different
from the way that many graphics libraries do their coordinates.

=cut

# working here - any Perl function definitions should go in this space

=head1 METHODS

Each of the functions described below actually installs itself twice, under two
different names. For a given function <func>, the low-level implementation will
be available under PDL::_prima_<func>_int. They are discussed below, but
generally you should stick with the widget-oriented high-level
implementation. The high-level implementation is installed under
Prima::Drawable::pdl_<func> and is meant to be invoked as an object
method:

 $widget->pdl_polyline($x, $y);




# working here






If you decide you want to call the low-level functions, to reduce the
error-processing overhead, perhaps, you need to supply each and every
argument, in the proper order.

The
low-level functions require a huge number of arguments. I describe below
how to infer their argument calling semantics from the provided list of
required arguments and optional parameters, but I generaly discourage
their use.
The low-level functions are the raw functions generated by PDL::PP. Their error
checking is limited and they are not exported. If you want access to these
functions, you must invoke them with the full PDL package prefix, as:



=cut







# Builds a piddle of patterns with the appropriate sizes, etc.
sub pdl_of_patterns_for {
}

ModuleMaterial

=for details
As far as I can tell, PDL::PP only defines the '_<func>_int' form of a function
when you specify a PMCode in the pp_def. I can't figure out where this happens
in PP.pm, but that appears to be the output behavior. For an introduction to
postscript, see http://local.wasp.uwa.edu.au/~pbourke/dataformats/postscript/
and http://www.physics.emory.edu/~weeks/graphics/howtops1.html

=cut

pp_addhdr( <<HEADER );

/* apricot is the (strangely named) header file that contains all of the
 * cross-platform functions.
 */

#undef WORD
#include <apricot.h>

HEADER

#######################################################################
#                              Machinery                              #
#######################################################################

=begin details

=head1 Complex parameter handling

Each of the functions in this module wrap a PDL function around the
Prima API. The goal of the PDL functions is to allow the caller to
provide as many or as few tweaks to their drawing as they wish, so if
they want to draw three different polylines with three different line
styles, they should be able to do this:

 $widget->pdl_polyline($xs, $ys, {linePatterns => $patterns});

and it will DWIM. That means that the PP functions have to (1) get all
the possible preferences in as parameters (preferably piddles), (2) the
PP functions have to call the appropriate functions from apricot.h
to do their work, and (3) the PP functions have to package their piddles
in a form that the apricot.h functions know how to handle. To make
matters even more complicated, different API functions pay attention to
different properties, so different ones apply for different functions!

To deal with all of this, the next 400 or so lines of code create some
machinery that greatly assists in building the pp_defs that follow. A
great deal of this code is used in THIS script (.pd files are actually
scripts that generate .xs and .pm files) to assist in generating code.
Anything that needs to end up in the output files will be quoted.

=end details

=cut

###################################################
# Creating the look-up table for the Pars section #
###################################################

=begin details

This hash translates from a simple parameter name to a PDL signature.
Without this hash, if I wanted to write a function that allows the user
to draw lines with different colors, I would write the following Pars:

  Pars => 'int x(n); int y(n); int colors()'

So in the hash below, the property C<colors> is associated with the
arg string C<int colors()>.

=end details

=cut

my %pars_args_for = (colors => 'int colors()');

=begin details

At the moment, I only have the colors property. If you know the Prima
Drawable API, you'll know I'm missing a lot! This is because I will
build up a number of structures over this discourse and I would
like to keep the code and specifications for each property in one place.
Scroll down to the 'Assembling machinery' portion of this code, about
175 lines below, and you'll see that all the parts for each of the
Drawable properties defined in one place.

=end details

=cut

#########################
# Generating Pars lists #
#########################

=begin details

This function creates a string with the low-level PDL function's argument
list, given a list of properties for the function.This makes it very
easy to make long parameter lists, and long parameter lists are nicely
handled by the in-pm function C<get_sorted_args_with_defaults>. To
expand on the previous example, in this code:

 pp_def(my_func,
        Pars => 'int x(n); int y(n); ' . generate_pars_args_for( 'colors', 'rops'),
        ...
 );

pp_def sees a parameter list that looks like this:

 'int x(n); int y(n); int colors(); int rops()'

To use this, I will create a list of properties that the to-be-defined
function takes, and use that together with generate_pars_args_for like
so:

 my @clear_properties = qw(backColors rop2s);
 pp_def(prima_clear,
        Pars => 'int x1(); int y1(); int x2(); int y2(); '
                 . generate_pars_args_for(@clear_properites),
        PMCode => ...
 );

It may seem silly to use such an array for only two additional arguments,
but other parts of the pp_def call will make use of that array, as we
will see.

=end details

=cut

sub generate_pars_args_for {
	return join('; ', @pars_args_for{@_});
}

######################################
# Property-dependent local variables #
######################################

=begin details

As already mentioned, many of the properties that could potentially be
sent to the drawing apricot.h functions will need a set of local
variables. Currently, clipRects and linePatterns need special variables
to do their work, and these variables should be created outside the
threadloop. (regions, when implemented, may need to use this, too.)
Functions that do not care about those properties will not need those
variables, so they should only be included in functions that actually
use them. generate_init_args_for handles this code generation, taking
the same array of properties used by generate_pars_args_for. See the
next section for an example of use.

Note that entries in C<%init_args_for> should be semi-colon seperated,
since they are C declarations, but the last entry should not have a 
semi-colon. One will be appended. This is to keep consistency with
C<%pars_args_for>, which has the same format.

=end details

=cut

my %init_args_for = ();

sub generate_init_args_for {
	my $to_return = '';
	# Build the list:
	foreach(@_) {
		$to_return .= "\t\t$init_args_for{$_};\n"
			if exists $init_args_for{$_};
	}
	
	# Don't say anything unless we're actually adding material:
	$to_return = "\t\t/* These are declarations needed for some of the optional parameters */\n"
		. $to_return if $to_return ne '';

	return $to_return;
}

##########################################
# Tracking which properties need setting #
##########################################

=begin details

The default argument for all of the properties is the null piddle. This
is very handy for the function definitions, but there's no way (that I
know of) to determine from PP code whether the supplied piddle was
originally null. However, I can examine the original hash passed in as
an argument to the Perl-level function. If the user specified a value
for a property, it will be present in the hash. If they did not, it will
not be there.

So, for each of the graphics properties that the user can supply for a
given function, I will want to have code in the PP Code section that
looks something like this:

 SV* arg_hash_HV = SvRV(arg_rev_sv);
 int is_setting_rops;
 is_setting_rop = hv_exists_ent(arg_hash_hv, sv_2mortal(newSVpv("rops", 0)), 0);

This code checks if the key "rops" exists in the arg_hash_hv hash (which
must be passed in to the PP function via OtherPars). The
return value is a boolean, which I will use in the threadloop. Looking
up these values once and storing their results will make the resulting
code much less cluttered, and hopefully faster.

Here's a function that generates the code for me, based on the supplied
list of properties. It's a little different from the example above, but
they basically do the same thing. It, too, uses the same array of
properties used by generate_pars_args_for. The auto-generated code from
this function is inserted directly into the Code key in the pp_def
function call, like so:

 my @func_pars = qw(backColor linePattern);
 pp_def('my_func',
     Pars => 'int arg1(n); ' . generate_pars_args_for(@func_pars),
     ...
     Code => q{
         /* set-up variables I will need throughout the threadloop */
         int alpha;
     } . generate_init_args_for(@func_pars)
       . create_boolean_setters_for(@func_pars)
     . q{
         alpha = -1;
         ... 
         threadloop %{
             ...
         %}
     },

=end details

=cut

sub create_boolean_setters_for {
	# Make sure I handle an empty list correctly. I can't imagine
	# calling this function with an empty list, but let's be safe:
	return '' unless @_;
	# This is the string I will build up for my return value:
	my $to_return = "
		/* The last of the declarations */
		SV* key;
		SV* arg_hash_hv;
		int ";
	# Create the variable list (is_setting_colors, is_setting_lineWidths...):
	$to_return .= join(', ', map {"is_setting_$_"} @_) . ";\n";
	
	# Set the variables:
	$to_return .= "
		/* Begin initializing the values */
		key = sv_newmortal();
		arg_hash_hv = SvRV(arg_ref_sv);
";
	foreach(@_) {
		$to_return .= "\t\tsv_setpv(key, \"$_\");\n"
					. "\t\tis_setting_$_ = hv_exists_ent(arg_hash_hv, key, 0);\n";
	}
	return $to_return;
}

####################################
# Creating the initialization code #
####################################

=begin details

I've built up a lot of machinery to handle the various required arguments
and optional properties. This next chunk of code gives a single function
that will call everything in the proper order to declare and initialize
the necessary variables, early within the Code section.

=end details

=cut

sub initialize_for {
	my @properties = @_;
	return '
		/* BEGIN AUTOGENERATED INITIALIZATION */

		/* In this code, I will have to work with widget Handles, not SVs */
		Handle widget_handle;
		
	' . generate_init_args_for(@properties)
	  . create_boolean_setters_for(@properties) . '

		/* transform the widget SV pointer into a handle */
		widget_handle = gimme_the_mate($COMP(widget_sv));
		
		/* END AUTOGENERATED INITIZLIATION */
	';
}

my $default_other_pars = 'SV * widget_sv; SV * arg_ref_sv';

#################################
# Calling the apricot.h setters #
#################################

=begin details

Each of the setters needs to first check if its call is even necessary
(using the boolean variables set-up in the previous section),
and then it needs to call the appropriate setter from apricot.h. This is
easy by repetitive code, so once again I generate it from the same
list of arguments as everything else. In what follows, I create a
function that generates these code fragments for me, or looks them up
in a hash if they're complicated. Note that the function wraps the
looked-up code in its own curly-braced block; all you need to write is
the code itself like the following colors example shows:

The auto-generated code for this section is inserted directly into the
Code key in the pp_def function call, within the threadloop, before the
apricot function for this function is itself called. For example:

 q[
     ...
     threadloop %{
		 /* Apply any per-threadloop tweaks */
         ] . generate_setter_code_for(@func_pars)
         . q[
         /* Call the apricot function */
         apc_gp_set_func(args);
     %}
 ]

=end details

=cut

my %set_code_for = (
	colors => q{
			/* cast the integer as a Colors type (which itself is a
			 * 32-bit int, so maybe this is unnecessary */
			apc_gp_set_color(widget_handle, (Color)$colors());
	},
);

sub generate_single_setter_code_for {
	my $property = shift;
	# Make the singular name from the plural:
	(my $singular = $property) =~ s/s$//;
	# apricot uses underscores and all lowercase instead of CamelCase:
	(my $apricot  = $singular) =~ s/([A-Z])/_\l$1/g;
	# Build the return string:
	my $to_return = "\t\t\tif (is_setting_$property) {\n";
	if (exists $set_code_for{$property}) {
		# Insert special handling code:
		$to_return .= $set_code_for{$property};
	}
	else {
		# Most other properties are direct sets:
		$to_return .= "\t\t\t\tapc_gp_set_$apricot(widget_handle, \$$property())\n";
	}
	
	$to_return .= "\t\t\t}";
}

sub generate_setter_code_for {
	return join("\n"
		, "\t\t\t/* BEGIN AUTOGENERATED SETTER CHECKS */\n"
		, (map {generate_single_setter_code_for($_)} @_)
		, "\n\t\t\t/* END AUTOGENERATED SETTER CHECKS */\n"
		); 
}

##################################################
# Building machinery for the different properies #
##################################################

=begin details

Now that I have all of the infrastructure ready, I need to build up the
data structures for each of the properties.

=end details

=cut

# Background color:
$pars_args_for{backColors} = 'int backColors()';
$set_code_for{backColors} = q{
			/* cast the integer as a Colors type (actually an int) */
			apc_gp_set_back_color(widget_handle, (Color)$backColors());
};

# Clipping rectangle:
$pars_args_for{clipRects} = 'int clipLeft(); int clipBottom(); int clipRight(); int clipTop()';
$init_args_for{clipRects} = 'Rect clip_rect';
$set_code_for{clipRects} = q{
			clip_rect.left = $clipLeft();
			clip_rect.bottom = $clipBottom();
			clip_rect.right = $clipRight();
			clip_rect.top = $clipTop();
			apc_gp_set_clip_rect(widget_handle, clip_rect);
};

# These do no need any special args, and the default generated code will
# work just fine:
$pars_args_for{lineEnds} = 'int lineEnds()';
$pars_args_for{lineJoins} = 'int lineJoins()';
$pars_args_for{lineWidths} = 'int lineWidths()';
$pars_args_for{rops} = 'int rops()';
$pars_args_for{rop2s} = 'int rop2s()';

# line patterns. This code has to cast the byte piddle into a char and
# send that and the length to the line_pattern function.
$pars_args_for{linePatterns} = 'byte linePatterns(patlen)';
$init_args_for{linePatterns} = 'unsigned char * pattern; int pattern_length';
$set_code_for{linePatterns} = q{
			pattern = (unsigned char)$P(linePatterns);
			pattern_length = strlen(pattern);
			apc_gp_set_line_pattern(widget_handle, pattern, pattern_length);
};

# translation; the apricot function for translate uses a different name
# and takes two arguments instead of one:
$pars_args_for{translates} = 'int trans_x(); int trans_y()';
$set_code_for{translates} = q{
			/* invoke the apricot function with both x and y */
			apc_gp_set_transform(widget_handle, $trans_x(), $trans_y());
};

# Fill winding works nicely without any alteration:
$pars_args_for{fillWindings} = 'int fillWindings()';

# Fill pattern will may work nicely without any alteration, but I am
# going to be explicit and cast the fillPattern piddle into a U8 array:
$pars_args_for{fillPatterns} = 'byte fillPatterns(oct=8)';
$set_code_for{fillPatterns} = q{
			/* Casts the pattern as a U8 pointer and continues */
			apc_gp_set_fill_pattern(widget_handle, (U8*)$P(fillPatterns));
};

# Spline precision works well with the default setup:
$pars_args_for{splinePrecisions} = 'int splinePrecisions()';

# Ignoring for now: region
# The underlying graphics functions explicitly operate with a 1-bit-per-pixel
# Prima::Image bitmap. I could use PDL::PrimaImage as the argument, but
# that seems like a lot of repackaging for every round in the PP
# threadloop. Alternatively, I could take an array ref with Prima::Image
# objects as the argument, and simply cycle through that.


#######################################################
# Argument processing, ordering, and default handling #
#######################################################

=begin details

Each of the perl-side functions that gets invoked as an object
method checks its arguments. It does this by analyzing the hash sent in
by the caller, checking for properties that don't belong, or were
mis-spelled, and repackaging the results into a list with the exact
order needed by the PP code. Most parameters take a single piddle as
their argument, but some don't. This code needs to know how many
arguments go with each parameter, so it can check that, too. Such a list
of parameters can be automatically constructed from the already-defined
%pars_args_for hash.

=end details

=cut

pp_addpm (join("\n"
	, '# This is a list of arguments for each property. It is based on the'
	, '# pars_args_for hash which is built in the .pd file associated with this module'
	, '# Note that the tr operator, as used, just counts the number of semi-colons'
	, '# in the pars args associated with the property.'
	, '%N_args_for = ('
	, (map {sprintf "\t%-20s => %d", $_, ($pars_args_for{$_} =~ tr/;//) + 1}
		(keys %pars_args_for))
	, ');'
	)
);

=begin details

Having collected the number of arguments associated with each of the
properties, I need a function to actually process the hash.
This is a function that I call in all of my PMCode sections. It takes an
anonymous list of names and an anonymous hash. If the hash has a key for
one of the names, it includes that in the return list. If it doesn't, it
returns the default value of a 0-dim piddle with value 0. If one of the
hash keys is not in the list of names, it croaks.

Put a little differently, this function takes an anonymous hash, makes
sure there are no extraneous arguments, extracts the desired arguments
or uses a sensible default, and returns the arguments in the desired
order.

=end details

=cut

pp_addpm <<'DefaultArgumentHandling';

sub get_sorted_args_with_defaults {
	my ($arg_names, $given) = @_;
	
	# Default to an empty list:
	$given = {} unless ref($given) eq 'HASH';
	
	# Check that they supplied only allowed parameters:
	foreach (keys %$given) {
		croak("Unknown parameter $_") unless $_ ~~ @$arg_names
	}
	
	# Return the sorted list of supplied or default values
	my @to_return = ();
	foreach (@$arg_names) {
		if (not exists $given->{$_}) {
			# If not supplied, return a null piddle
			push @to_return, PDL->nullcreate(0);
		}
		elsif (ref ($given->{$_}) eq 'ARRAY') {
			# If an array ref, dereference it and make sure the number
			# of arguments agrees with what we expect:
			if (@{$given->{$_}} != $N_args_for{$_}) {
				croak("Expected 1 argument for $_") if $N_args_for{$_} == 1;
				croak("Expected $N_args_for{$_} arguments in the anonymous hash for $_");
			}
			push @to_return, @{$given->{$_}};
		}
		else {
			# Otherwise, return it outright, if we only expected one
			# argument:
			$N_args_for{$_} == 1
				or croak("Expected $N_args_for{$_} elements in an anonymous hash for $_");
			
			push @to_return, $given->{$_};
		}
	}
	return @to_return;
}

DefaultArgumentHandling


###################################
# Generating PMCode automatically #
###################################

=begin details

The PMCode section of each of these is pretty much the same. This
snippet of code generates that code for me. It takes the names of the
arguments and returns the autogenerate PMCode.

This code is very dense. I hope that it is documented well enough with
comments that any future maintainer will be able to understand it. If
in doubt, this function operates stand-alone, so you can copy it into
a little test script and try calling it with sample parameters to get a
feel for how it behaves.

working here - I have a few argument checking
ideas for this function, including
considering checking that C<$self> is a Prima::Drawable type, but not
Prima::PS::Drawable. Also, I bet if PDL barfs, it'll point to the line
in the (generated) pm file, so the pdl function call should probably be
wrapped in an eval block, and $@ should be post-processed.

=end details

=cut

sub generate_PMCode_for {
	my ($func_name, $props, @arg_names) = @_;
	my $props_array_name = '@' . $func_name . '_props';
	my $args_array_name = '@' . $func_name . '_args';
	# Outside the function definition, create the list of properties
	# that this function uses, as well as the names of the arguments.
	# It needs these lists in the actual Perl module file so it can
	# check the passed arguments and provide meaningful error messages:
	my $to_return = "my $props_array_name = qw(@$props);\n"
				. "my $args_array_name = qw(@arg_names);\n";
	
	# Define the drawable function in the Prima::Drawable namespace
	# and check for arguments:
	$to_return .= "sub Prima::Drawable::pdl_$func_name {
	# Before anything else, make sure they supplied at least the
	# required number of arguments:
	croak('pdl_$func_name expectes '. scalar($args_array_name)
		. ' arguments (and the widget): ' . join(', ', 'widget', $args_array_name))
		unless (\@_ > $args_array_name);

	# unpack the widget and the required arguments for this function:
";
	foreach ('self', @arg_names) {
			$to_return .= "\tmy \$$_ = shift;\n";
	}
	$to_return .= "
	# Check for an even number of remaining arguments (key-value pairs):
	croak('pdl_$func_name expects optional parameters ans key => value pairs')
		unless \@_ % 2 == 0;	# *strictly* greater accounts for \$self
	
	my \%args = \@_;
	
	# Get the a full list of arguments suitable for the internal pp code
	# in the correct order:
	my \@args_with_defs
		= get_sorted_args_with_defaults(\\$props_array_name, \\\%args);

	# Call the PP'd internal code. Always put self and the args hash
	# last.
	PDL::_prima_${func_name}_int(";
	# include all the required arguments:
	foreach(@arg_names) {
		$to_return .= '$' . $_ . ', ';
	}
	# finish with self and the args list:
	$to_return .= '@args_with_defs, $self, \%args);' . "\n}\n";
	 
	return $to_return;
}


#######################################################################
#                              Functions                              #
#######################################################################

##################
# prima_polyline #
##################

=begin details

At last I begin the declaration of PP code. The idea behind all of this
machinary is that I declare a collection of applicable properties in
THIS SCRIPT, and then use that to generate consistent code blocks

=end details

=cut

my @polyline_props = qw(colors backColors linePatterns lineWidths lineJoins
						lineEnds rops rop2s);
pp_def('prima_polyline',
	Pars => 'int x(n); int y(n); ' . generate_pars_args_for(@polyline_props),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('polyline', \@polyline_props, qw(x, y)),
	Code => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i;
	}
	# Add the auto-generated declaration and initialiation code:
	. initialize_for(@polyline_props)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Run through the data and draw it. */
		threadloop %{
			/* Put the x-y data into the to_plot array */
			loop (n) %{
				to_plot[n].x = $x();
				to_plot[n].y = $y();
			%}
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. conditionally_call_setters_for(@polyline_props)
		. q[
			
			/* Call apricot's polyline function */
			apc_gp_draw_poly(widget_handle, n_size, to_plot);
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	Doc => <<'EOD'

=head2 polyline

  Prima Signature: (widget; x(n); y(n); properties)

=for ref

Draws a multi-segment line on a widget with the given x- and y-coordinates.

This is useful for making quick line-drawings on your 

=for example

 # Draw a sine curve on the widget:
 my $x = sequence(200);
 my $y = ( sin($x / 20) + 1 ) * 50;
 $widget->pdl_polyline($x, $y);

=cut

EOD
);

=begin later

This is a bit of Postscript handling code which will eventually need to
be fleshed out. But that'll have to come later. Perhaps I will put the
postscript code in its own .pd file since it is fairly different from
the apricot-based code.

pp_def('prima_ps_polyline_stroke',
	Pars => 'int x(n); int y(n)',
	OtherPars => 'SV * stroke_sv',
	GenericTypes => ['L'],
	PMCode => q{
		sub Prima::PS::Drawable::pdl_polyline {
			my ($self, $x, $y) = @_;
			
			# Create the Perl scalar which I will fill with stroke commands
			my $to_stroke = '';
			
			# Construct the stroke:
			PDL::_prima_ps_polyline_stroke_int($x, $y, $to_stroke);
			
			# At this point, $to_stroke has been filled with postscript commands
			# for drawing the polyline. Finish by calling the stroke:
			$self->stroke('', $to_stroke, '');
		}
	},
	Code => q{
		int n_size, i;
		n_size = $SIZE(n);
		
		/* Run through the data and concatenate the PS commands to draw it. */
		threadloop %{
			/* Begin by moving to the first point. Prima defines the shorthands
			 * N for 'newpath' and M for 'move'
			 */
			sv_catpvf(stroke_sv, "N %f %f M ", $x(n=>0), $y(n=>0));
			
			/* Put the rest of the x-y data into the stroke string. Prima
			 * defines the shorthand l for 'lineto'
			 */
			for (i = 1; i < n_size; i++) {
				sv_catvfg(stroke_sv, "%f %f l ", $x(n=>i), $y(n=>i));
			}
			
			/* Finish the command by appending a capital O, which Prima defines
			 * as a shorthand for 'stroke'
			 */
			sv_catpv(stroke_sv, "O\n");
		%}
	},
	Doc => <<'EOD'


=head2 polyline

  Prima Signature: (widget; x(n); y(n))
  PDL Signatue: (x(n); y(n); widget)

=for ref

Draws a multi-segment line on a widget with the given x- and y-coordinates.

This is useful for making quick line-drawings on your 

=for example

 # Draw a sine curve on the widget:
 my $x = sequence(200);
 my $y = ( sin($x / 20) + 1 ) * 50;
 $widget->pdl_polyline($x, $y);

 =cut

EOD

);

=end later

=cut

pp_addpm({At=>'Bot'},<<'EOD');

=head1 ERROR MESSAGE

This function may throw the following exception:

=head2 Your widget must be derived from Prima::Drawable

This means that you tried to draw on something that is not a Prima::Drawable
object, or a class derived from it. I don't know enough about the Prima
internals to know if that has any hope of working, but why do it in the first
place?

=head1 TODO

These are all the things I wish to do:

=over

=item Full Drawabel API

I would like a PDL function for every drawable function in the API.

=item PS Functionality

Currently, this library only implements PDL functions using the apricot
library. Since L<Prima::PS::Drawable> implements its own drawing
functions, none of the PDL drawing functions will work.
They need their own specially created functions that will emit postscript
code. That may prove challenging, and will likely require a seperate
interface with a reduced number of optional properties.

=item Bad Value Support

PLplot's bindings have a very sensible interpretation for bad values: they are
omitted. This should be replicated in this library.

=item Full Options Support

I want to take PDL arrays for all of the drawing options, especially color and
line thickness. This way, one could draw 15 lines with 15 different colors and
thicknesses simply by specifying thickness and color piddles.

=back

=head1 AUTHOR

David Mertens, E<lt>dcmertens.perl@gmail.comE<gt>.

=head1 SEE ALSO

The Perl Data Language, L<PDL>

The Prima toolkit, http://www.prima.eu.org/, L<Prima>

Since this amounts to a plotting package, you should check out other plotting
packages available for PDL. Two notable examples are L<PDL::Graphics::PLplot>
and L<PDL::Graphics::PGPLOT>.

Another interface between PDL and Prima is <PDL::PrimaImage>. I am indebted to
Dmitry for that module because it gave me a working template for this module,
including a working Makefile.PL. Thanks Dmitry!

=cut

EOD

