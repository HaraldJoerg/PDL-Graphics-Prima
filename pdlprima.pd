use strict;
use warnings;
use Carp 'croak';

pp_addpm({At=>'Top'},<<'ModuleMaterial');

BEGIN { 
$VERSION = '1.00'; 
} 

use strict;
use warnings;
use PDL;
use PDL::Char;
use Scalar::Util 'blessed';
use Carp 'croak';
use Prima;

# working here - use Exporter and set as 'EXPORT_OK' the functions
# pdl_of_patterns_for and pdl_of_handles_for. I need to write them, too.
# Their usage looks like this:
#  my $patters = pdl_of_patterns_for($pat1, $pat2, ...);
#  my $handles = pdl_of_handles_for($widget1, $widget2, ...);

=head1 NAME

PDL::Graphics::Prima - PDL-aware drawing functions for Prima widgets

=head1 SYNOPSIS

 # working here - make a useful synopsis

=head1 DESCRIPTION

working here - write this

=head2 Line patterns

It may happen that you want to draw a number of different lines, each with a
different line patter. There is a slight subtlety in how you do this.

Use byte arrays (or it will be cast to a byte array for you). All of the
patterns must have the same number of bytes in their specification, but there's
a decent chance that those specifications are different lenghts. In that case,
simply pad the shorter specifications with zeroes.

=head1 CONSIDERATIONS

The Prima image coordinate origin is located in lower left corner, which is
where you would expect to find it when creating plots. However, it is different
from the way that many graphics libraries do their coordinates.

=head1 GRAPHING

This module installs the C<graph> method into the Prima::Drawable
namespace, enabling all widgets to draw graphs. The arguments to
C<graph> are (1) anonymous arrays with the data you want to plot
together with their polylines arguments and (2) an anonymous hash with
the plot options. Plot options include:

=over

=item scaling

One of 'linear', 'logx', 'logy', or 'logxy'. This sets the scaling of
your plots.

=item xmin, xmax, ymin, ymax

The x- and y- clipping of your plot.

=item xlabel, ylabel

The x- and y- label for your plot.

=item viewport

The relative size of the plotting box of your graph. Four-element
anonymous array with values between 0 and 1, corresponding to left,
bottom, right, top. Default values are 0.1, 0.1, 0.9, and 0.9.

=back

=cut

sub rescale_to_pixels {
	my ($data, $data_min, $data_max, $pixel_extent, $pixel_offset) = @_;
	return (($data - $data_min) / ($data_max - $data_min)
			* $pixel_extent + $pixel_offset);
}

our $offset_penalty = 2;

sub _adjusted_position {
	my ($value, $interval, $offset, $direction) = @_;
	# Find the first copy of $interval that's less than $value:
	my $to_return = int($value / $interval) * $interval;
	# include the offset:
	$to_return += $offset;
	while(1) {
		return $to_return if $value == $to_return;
		return $to_return if (($to_return <=> $value) == $direction);
		$to_return += $direction * $interval;
	}
	# Return the final, adjusted position:
	return $to_return;
}

sub compute_linear_ticks {
	my ($min, $max) = @_;
	
	# This algorithm was designed with the following major tick layout
	# examples in mind:
	#	min  	max		ticks at
	#	2		4		2, 2.5, 3, 3.5, 4
	#	2.2		4.3		2.25, 2.75, 3.25, 3.75, 4.25 (maybe)
	#					2.4, 2.8, 3.2, 3.6, 4.0 (maybe)
	#	0		20		0, 5, 10, 15, 20
	#	30.5	37.5	31, 33, 35, 37
	#	0		112		0, 25, 50, 75, 100
	
	# Determine the order of magnitude of the min/max range:
	my $full_range = $max - $min;
	# Start by assuming that the order of magnitude will be a good
	# step size:
	my $exponent = log($max - $min) / log(10);
	# Correct for tracation of negative numbers:
	$exponent-- if $exponent < 0;
	my $order_of_magnitude = 10**(int $exponent);
	# Score each potential interval and take the lowest one:
	my $best_score = 100;
	my $best_Ticks;
	my $best_interval;
	my $best_scaled_interval;
	my $best_offset;
	
	my %intervals # interval	# handicap
		= qw(		0.25		0
					0.3			0.5
					0.4			0.25
					0.5			0
					0.6			0.5
					0.8			0.25
					1			0
					2			0.25
					2.5			0
					3			0.5
					4			0.25
		);
	
	while (my ($scaled_interval, $handicap) = each %intervals) {
		my $interval = $order_of_magnitude * $scaled_interval;
		for my $offset (0, $interval/2) {
			# The ticks will start at either a multiple of the interval,
			# or a multiple of the interval plus the offset. So,
			# recompute the range in light of the tick size:
			my $min_Tick = _adjusted_position($min, $interval, $offset, 1);
			my $max_Tick = _adjusted_position($max, $interval, $offset, -1);
			
			# Count the number of ticks between min_Tick and max_Tick
			my $N_Ticks = ($max_Tick - $min_Tick) / $interval + 1;
			
			# Obviously, max tick and min tick must not overlap:
			next if $N_Ticks < 2;
			
			# compute the score:
			$handicap += $offset_penalty if $offset != 0;
			my $score = (abs($N_Ticks - 5) + $handicap)**2;
			
			# If it's the best score, use it:
			if ($score < $best_score) {
				$best_score = $score;
				# Add 0.1 to N_Ticks to avoid rounding dilemas:
				$best_Ticks = zeroes($N_Ticks + 0.1)->xlinvals($min_Tick, $max_Tick);
				$best_interval = $interval;
				$best_scaled_interval = $scaled_interval;
				$best_offset = $offset;
			}
		}
	}
	
	# Construct the minor tick marks:
	my $tick_interval;
	if ($best_scaled_interval eq '0.3'
			or $best_scaled_interval eq '3'
			or $best_scaled_interval eq '0.6'
	) {
		$tick_interval = $best_interval / 6;
	}
	elsif (($best_scaled_interval eq '0.25'
			or $best_scaled_interval eq '0.5'
			or $best_scaled_interval eq '2.5'
			) and $best_offset == 0
	) {
		$tick_interval = $best_interval / 5;
	}
	else {
		$tick_interval = $best_interval / 4;
	}
	my $min_tick = _adjusted_position($min, $tick_interval, $best_offset, 1);
	my $max_tick = _adjusted_position($max, $tick_interval, $best_offset, -1);
	my $N_ticks = ($max_tick - $min_tick) / $tick_interval + 1.1;
	# Add 0.1 to escape rounding trouble.
	my $ticks = zeroes($N_ticks)->xlinvals($min_tick, $max_tick);

	# finally, set up zero values that make sense:
	$best_Ticks->where(abs($best_Ticks) * 1e10 < ($max - $min)) .= 0;
	$ticks->where(abs($ticks) * 1e10 < ($max - $min)) .= 0;
	return ($best_Ticks, $ticks);
}

# This algorithm was based almost entirely off the linear ticks
# algorithm, with a few special tweaks.
sub compute_log_ticks {
	# These are the LOGARITHMS of the actual data's min and max:
	my ($min, $max) = @_;
	
	die "Not yet implemented";

=pod	

	# Determine the order of magnitude of the min/max range:
	my $full_range = $max - $min;
	# Start by assuming that the order of magnitude will be a good
	# step size:
	my $order_of_magnitude = 10**(int (log($max - $min) / log(10)));
	
	# Score each potential interval and take the lowest one:
	my $best_score = 100;
	my $best_Ticks;
	my $best_interval;
	my $best_scaled_interval;
	
	my %intervals # interval	# handicap
		= qw(		0.25		0
					0.3			0
					0.5			0
					1			0
					2			0.25
					2.5			0
					3			0.5
					4			0.25
		);
	
	while (my ($scaled_interval, $handicap) = each %intervals) {
		my $interval = $order_of_magnitude * $scaled_interval;
		# The ticks will start at either a multiple of the interval,
		# or a multiple of the interval plus the offset. So,
		# recompute the range in light of the tick size:
		my $min_Tick = _adjusted_log_position($min, $interval, 1);
		my $max_Tick = _adjusted_log_position($max, $interval, -1);
		
		# Obviously, max tick and min tick must not overlap:
		next if $max_Tick <= $min_Tick;
		
		# Count the number of ticks between min_Tick and max_Tick
		# and compute the score:
		my $N_Ticks = ($max_Tick - $min_Tick) / $interval + 1;
		$handicap += $offset_penalty if $offset != 0;
		my $score = (abs($N_Ticks - 5) + $handicap)**2;
		
		# If it's the best score, use it:
		if ($score < $best_score) {
			$best_score = $score;
			# Add 0.1 to N_Ticks to avoid rounding dilemas:
			$best_Ticks = zeroes($N_Ticks + 0.1)->xlinvals($min_Tick, $max_Tick);
			$best_interval = $interval;
			$best_scaled_interval = $scaled_interval;
		}
	}
	
	# Construct the minor tick marks:
	my $tick_interval;
	if ($best_scaled_interval eq '0.3'
			or $best_scaled_interval eq '3'
			or $best_scaled_interval eq '0.6'
	) {
		$tick_interval = $best_interval / 6;
	}
	elsif (($best_scaled_interval eq '0.25'
			or $best_scaled_interval eq '0.5'
			or $best_scaled_interval eq '2.5'
			) and $best_offset == 0
	) {
		$tick_interval = $best_interval / 5;
	}
	else {
		$tick_interval = $best_interval / 4;
	}
	my $min_tick = _adjusted_position($min, $tick_interval, $best_offset, 1);
	my $max_tick = _adjusted_position($max, $tick_interval, $best_offset, -1);
	my $N_ticks = ($max_tick - $min_tick) / $tick_interval + 1.1;
	# Add 0.1 to escape rounding trouble.
	my $ticks = zeroes($N_ticks)->xlinvals($min_tick, $max_tick);

	# finally, set up zero values that make sense:
	$best_Ticks->where(abs($best_Ticks) * 1e10 < ($max - $min)) .= 0;
	$ticks->where(abs($ticks) * 1e10 < ($max - $min)) .= 0;
	return ($best_Ticks, $ticks);

=cut

}

sub Prima::Drawable::graph {
	my ($canvas, @args) = @_;
	my %options = ();
	if (ref($args[-1]) eq 'HASH') {
		%options = %{pop @args};
	}
	
	# Get the scaling parameter:
	my $scaling = 'linear';
	$scaling = $options{scaling} if exists $options{scaling};

	# The rest of @args are the datasets, together with their arguments
	# that go to polyline.
	
	# Process the min/max specifications:
	my ($xmin, $ymin, $xmax, $ymax) = @options{qw(xmin ymin xmax ymax)};
	
	# Get the min/max from the data if it's not already specified
	if (not defined $xmin or not defined $ymin or not defined $xmax
			or not defined $ymax) {
		foreach(@args) {
			if (not $options{xmin}) {
				$xmin = $_->[0]->min if (not defined $xmin or $_->[0]->min < $xmin);
			}
			if (not $options{ymin}) {
				$ymin = $_->[1]->min if (not defined $ymin or $_->[1]->min < $ymin);
			}
			if (not $options{xmax}) {
				$xmax = $_->[0]->max if (not defined $xmax or $_->[0]->max > $xmax);
			}
			if (not $options{ymax}) {
				$ymax = $_->[1]->max if (not defined $ymax or $_->[1]->max > $ymax);
			}
		}
	}
	
	if ($scaling =~ /logx/) {
		croak("Minimum and maximum values must be strictly positive for logarithmic scaling")
			unless ($xmin > 0 and $xmax > 0);
		# Rescale the min/max
		$xmin = log($xmin) / log(10);
		$xmax = log($xmax) / log(10);
		
		# Rescale the data:
		foreach (@args) {
			$_->[0] = log($_->[0]) / log 10;
		}
	}
	if ($scaling =~ /logx?y/) {
		croak("Minimum and maximum values must be strictly positive for logarithmic scaling")
			unless ($ymin > 0 and $ymax > 0);
		# Rescale the min/max
		$ymin = log($ymin) / log(10);
		$ymax = log($ymax) / log(10);
		
		# Rescale the data:
		foreach (@args) {
			$_->[1] = log($_->[1]) / log 10;
		}
	}
	
	# Get the viewport
	my @viewport = (0.1, 0.1, 0.9, 0.9);
	if (exists $options{viewport}) {
		croak("Viewport must be a four-element anonymous array")
			unless (ref($options{viewport})
					and ref($options{viewport}) eq 'ARRAY'
					and @{$options{viewport}} == 4);
		foreach (@{$options{viewport}}) {
			croak("Viewport boundaries must be between 0 and 1")
				unless $_ >= 0 and $_ <= 1;
		}
		croak("Viewport's bottom must be lower than the top")
			if $options{viewport}->[1] >= $options{viewport}->[3];
		croak("Viewport's left edge must be to the left of the right edge")
			if $options{viewport}->[0] >= $options{viewport}->[2];
	
		# If we're here, then all is well.
		@viewport = @{$options{viewport}};
	}
	# Conver the viewport to pixels and apply it:
	my ($x_size, $y_size) = $canvas->size;
	$viewport[0] *= $x_size;
	$viewport[1] *= $y_size;
	$viewport[2] *= $x_size;
	$viewport[3] *= $y_size;
	$canvas->clipRect(@viewport);
	
	# Compute the extent of the viewport in pixels:
	my $x_extent = $viewport[2] - $viewport[0];
	my $y_extent = $viewport[3] - $viewport[1];
	
	# Save the canvas's current properties that may be overwritten
	# by the polylines calls:
	my @to_backup = qw(color backColor linePattern lineWidth lineJoin
			lineEnd rop rop2);
	my %backups = map {$_ => $canvas->$_} (@to_backup);
	
	# Draw the data
	foreach(@args) {
		# Unpack the drawing specs:
		my ($xs, $ys, %props) = @$_;
		# Rescale x and y to pixel values:
		my $x_to_plot = rescale_to_pixels($xs, $xmin, $xmax, $x_extent, $viewport[0]);
		my $y_to_plot = rescale_to_pixels($ys, $ymin, $ymax, $y_extent, $viewport[1]);
		# Call the plotting routine:
		$canvas->pdl_polylines($x_to_plot, $y_to_plot, %props);
		# Reset the parameters in case they were changed:
		$canvas->set(%backups);
	}
	
	# Reset the clipping rectangle to the full canvas and draw a box
	# around the data:
	$canvas->clipRect(0, 0, $x_size, $y_size);
	$canvas->rectangle(@viewport);
	
	# Draw the tick marks:
	my ($xTicks, $xticks, $yTicks, $yticks);
#	if ($scaling =~ /logx/) {
#		($xTicks, $xticks) = compute_log_ticks($xmin, $xmax);
#	}
#	else {
		($xTicks, $xticks) = compute_linear_ticks($xmin, $xmax);
#	}
#	if ($scaling =~ /logx?y/) {
#		($yTicks, $yticks) = compute_log_ticks($ymin, $ymax);
#	}
#	else {
		($yTicks, $yticks) = compute_linear_ticks($ymin, $ymax);
#	}

	my $xticks_pixels = rescale_to_pixels($xticks, $xmin, $xmax, $x_extent, $viewport[0]);
	my $xTicks_pixels = rescale_to_pixels($xTicks, $xmin, $xmax, $x_extent, $viewport[0]);
	my $yticks_pixels = rescale_to_pixels($yticks, $ymin, $ymax, $y_extent, $viewport[1]);
	my $yTicks_pixels = rescale_to_pixels($yTicks, $ymin, $ymax, $y_extent, $viewport[1]);

	# Draw the tick marks:
	my $top_bottom = pdl($viewport[1], $viewport[3])->transpose;
	my $left_right = pdl($viewport[0], $viewport[2])->transpose;
	my $tick_length = sqrt($x_size);
	$tick_length = sqrt($y_size) if sqrt($y_size) < $tick_length;
	$tick_length *= 0.8;
	my $Tick_size = pdl($tick_length, -$tick_length)->transpose;
	my $tick_size = $Tick_size / 2;
	$canvas->pdl_lines($xticks_pixels, $top_bottom, $xticks_pixels, $top_bottom + $tick_size);
	$canvas->pdl_lines($xTicks_pixels, $top_bottom, $xTicks_pixels, $top_bottom + $Tick_size);
	$canvas->pdl_lines($left_right, $yticks_pixels, $left_right + $tick_size, $yticks_pixels);
	$canvas->pdl_lines($left_right, $yTicks_pixels, $left_right + $Tick_size, $yTicks_pixels);
	
	# Draw the tick labels
	for (my $i = 0; $i < $xTicks->nelem; $i++) {
		my $x = $xTicks_pixels->at($i);
		my $string = sprintf("%1.8g", $xTicks->at($i));
		$canvas->draw_text($string
			, $x-80, 0, $x+80, $viewport[1] - 2*log($y_size)
			, dt::Top | dt::Center
			);
	}
	for (my $i = 0; $i < $yTicks->nelem; $i++) {
		my $y = $yTicks_pixels->at($i);
		my $string = sprintf("%1.8g", $yTicks->at($i));
		$canvas->draw_text($string
			, 0, $y-80, $viewport[0] - 2*log($x_size), $y+80
			, dt::Right | dt::VCenter
			);
	}
	
	# Position the labels
	if ($options{xlabel}) {
		$canvas->draw_text($options{xlabel}
			, 0, 0, $x_size, $viewport[1]/2
			, dt::Center | dt::Top
			);
	}
	if ($options{ylabel}) {
		$canvas->font(direction => 90);
		$canvas->draw_text($options{ylabel}
			, 0, 0, $viewport[0]/2, $y_size
			, dt::VCenter | dt::Right
		);
		$canvas->font(direction => 0);
	}
}

=head1 METHODS

Each of the functions described below actually installs itself twice, under two
different names. For a given function <func>, the low-level implementation will
be available under PDL::_prima_<func>_int. They are discussed below, but
generally you should stick with the widget-oriented high-level
implementation. The high-level implementation is installed under
Prima::Drawable::pdl_<func> and is meant to be invoked as an object
method:

 $widget->pdl_polyline($x, $y);




# working here






If you decide you want to call the low-level functions, to reduce the
error-processing overhead, perhaps, you need to supply each and every
argument, in the proper order.

The
low-level functions require a huge number of arguments. I describe below
how to infer their argument calling semantics from the provided list of
required arguments and optional parameters, but I generaly discourage
their use.
The low-level functions are the raw functions generated by PDL::PP. Their error
checking is limited and they are not exported. If you want access to these
functions, you must invoke them with the full PDL package prefix, as:



=cut







# Builds a piddle of patterns with the appropriate sizes, etc.
sub piddle_of_patterns_for {
	# Make sure they're not being stupid:
	croak("You must supply at least one pattern to make a pattern piddle")
		if @_ == 0;

	# First get the longest pattern:
	my $length = 0;
	foreach(@_) {
		$length = length($_) if $length < length($_);
	}
	
	use PDL::NiceSlice;
	
	# Create the new byte array with the appropriate dimensions:
	my $to_return = zeroes(byte, $length, scalar(@_));
	$to_return .= $to_return->sequence;
	for (my $i = 0; $i < @_; $i++) {
		# Get a slice and update it:
		my $slice = $to_return(:,$i);
		substr ${$slice->get_dataref}, 0, length($_[$i]), $_[$i];
		
		# Make sure the modifications propogate back to the original:
		$slice->upd_data;
	}
	
	no PDL::NiceSlice;
	
	return $to_return;
}

sub piddle_of_handles_for {
	# Make sure they're not being stupid:
	croak("You must supply at least one widget from which to get a handle")
		if @_ == 0;
	
	# Make sure all of the variables are indeed widgets:
	foreach(@_) {
		croak("One or more of your widgets does not seem to be descended from Prima::Drawable")
			unless blessed($_) and $_->isa('Prima::Drawable');
	}
	
	# Make a piddle large enough to hold the handles:
	my $to_return = zeroes(long, scalar(@_));
	
	# put the handles in the piddle:
	_piddle_of_handles_for(${$to_return->get_dataref}, @_);
	
	# Update the piddle and return it:
	$to_return->upd_data;
	return $to_return;
}

ModuleMaterial

pp_addxs('', q{
void
_piddle_of_handles_for(SV * piddle_SV, ...)
	CODE:
		int i;
		/* Get at the piddle's actual data array */
		long * piddle = (long*)SvPVX(piddle_SV);
		/* Fill the array with the handle values */
		for (i = 1; i < items; i++) {
			piddle[i-1] = gimme_the_mate(ST(i));
		}

});
=for details
As far as I can tell, PDL::PP only defines the '_<func>_int' form of a function
when you specify a PMCode in the pp_def. I can't figure out where this happens
in PP.pm, but that appears to be the output behavior. For an introduction to
postscript, see http://local.wasp.uwa.edu.au/~pbourke/dataformats/postscript/
and http://www.physics.emory.edu/~weeks/graphics/howtops1.html

=cut

pp_addhdr( <<HEADER );

/* apricot is the (strangely named) header file that contains all of the
 * cross-platform functions.
 */

#undef WORD
#include <apricot.h>
#define ONE_MILLION 1000000

HEADER

#######################################################################
#                              Machinery                              #
#######################################################################

=begin details

=head1 Complex parameter handling

Each of the functions in this module wrap a PDL function around the
Prima API. The goal of the PDL functions is to allow the caller to
provide as many or as few tweaks to their drawing as they wish, so if
they want to draw three different polylines with three different line
styles, they should be able to do this:

 $widget->pdl_polyline($xs, $ys, {linePatterns => $patterns});

and it will DWIM. That means that the PP functions have to (1) get all
the possible preferences in as parameters (preferably piddles), (2) the
PP functions have to call the appropriate functions from apricot.h
to do their work, and (3) the PP functions have to package their piddles
in a form that the apricot.h functions know how to handle. To make
matters even more complicated, different API functions pay attention to
different properties, so different ones apply for different functions!

To deal with all of this, the next 400 or so lines of code create some
machinery that greatly assists in building the pp_defs that follow. A
great deal of this code is used in THIS script (.pd files are actually
scripts that generate .xs and .pm files) to assist in generating code.
Anything that needs to end up in the output files will be quoted.

=end details

=cut

###################################################
# Creating the look-up table for the Pars section #
###################################################

=begin details

This hash translates from a simple parameter name to a PDL signature.
Without this hash, if I wanted to write a function that allows the user
to draw lines with different colors, I would write the following Pars:

  Pars => 'int x(n); int y(n); int colors()'

So in the hash below, the property C<colors> is associated with the
arg string C<int colors()>, and (not-optional, but specially processed)
C<handles> property is associated with the arg string C<int handles()>.

=end details

=cut

my %pars_args_for = (colors => 'int colors()'
	, handles => 'int handles()'
);

=begin details

At the moment, I only have the colors property. If you know the Prima
Drawable API, you'll know I'm missing a lot! This is because I will
build up a number of structures over this discourse and I would
like to keep the code and specifications for each property in one place.
Scroll down to the 'Assembling machinery' portion of this code, about
175 lines below, and you'll see that all the parts for each of the
Drawable properties defined in one place.

=end details

=cut

#########################
# Generating Pars lists #
#########################

=begin details

This function creates a string with the low-level PDL function's argument
list, given a list of properties for the function. This makes it very
easy to manage long parameter lists, and long parameter lists are nicely
handled by the in-pm function C<get_sorted_args_with_defaults>. It also
adds handles to the signature, which is mandatory for each of these
functions. To expand on the previous example, in this code:

 pp_def(my_func,
        Pars => 'int x(n); int y(n); ' . generate_pars_args_for( 'colors', 'rops'),
        ...
 );

pp_def sees a parameter list that looks like this:

 'int x(n); int y(n); int handles(); int colors(); int rops()'

To use this, I will create a list of properties that the to-be-defined
function takes, and use that together with generate_pars_args_for like
so:

 my @clear_properties = qw(backColors rop2s);
 pp_def(prima_clear,
        Pars => 'int x1(); int y1(); int x2(); int y2(); '
                 . generate_pars_args_for(@clear_properites),
        PMCode => ...
 );

It may seem silly to use such an array for only two additional arguments
(as shown in this example), but other parts of the pp_def call will make
use of that array, as we will see, and most of the functions use many
more properties.

=end details

=cut

sub generate_pars_args_for {
	foreach (@_) {
		croak("Bad args; should be plural") unless /s$/;
	}
	return join('; ', @pars_args_for{'handles', @_});
}

######################################
# Property-dependent local variables #
######################################

=begin details

As already mentioned, many of the properties that could potentially be
sent to the drawing apricot.h functions will need a set of local
variables. Currently, clipRects and linePatterns need special variables
to do their work, and these variables should be created outside the
threadloop. (regions, when implemented, may need to use this, too.)
Functions that do not care about those properties will not need those
variables, so they should only be included in functions that actually
use them. generate_init_args_for handles this code generation, taking
the same array of properties used by generate_pars_args_for. See the
next section for an example of use.

Note that entries in C<%init_args_for> should be semi-colon seperated,
since they are C declarations, but the last entry should not have a 
semi-colon. One will be appended. This is to keep consistency with
C<%pars_args_for>, which has the same format.

=end details

=cut

my %init_args_for = ();

sub generate_init_args_for {
	my $to_return = "\t\t/* These are declarations needed for the handles
		 * and some of the optional parameters */
		 Handle widget_handle;\n";
	# Build the list:
	foreach(@_) {
		$to_return .= "\t\t$init_args_for{$_};\n"
			if exists $init_args_for{$_};
	}
	
	return $to_return;
}

##########################################
# Tracking which properties need setting #
##########################################

=begin details

The default argument for all of the properties is the null piddle. This
is very handy for the function definitions, but there's no way (that I
know of) to determine from PP code whether the supplied piddle was
originally null. However, I can examine the original hash passed in as
an argument to the Perl-level function. If the user specified a value
for a property, it will be present in the hash. If they did not, it will
not be there.

So, for each of the graphics properties that the user can supply for a
given function, I will want to have code in the PP Code section that
looks something like this:

 SV* arg_hash_HV = SvRV(arg_rev_sv);
 int is_setting_rops;
 is_setting_rop = hv_exists_ent(arg_hash_hv, sv_2mortal(newSVpv("rops", 0)), 0);

This code checks if the key "rops" exists in the arg_hash_hv hash (which
must be passed in to the PP function via OtherPars). The
return value is a boolean, which I will use in the threadloop. Looking
up these values once and storing their results will make the resulting
code much less cluttered, and hopefully faster.

Here's a function that generates the code for me, based on the supplied
list of properties. It's a little different from the example above, but
they basically do the same thing. It, too, uses the same array of
properties used by generate_pars_args_for. The auto-generated code from
this function is inserted directly into the Code key in the pp_def
function call, like so:

 my @func_pars = qw(backColor linePattern);
 pp_def('my_func',
     Pars => 'int arg1(n); ' . generate_pars_args_for(@func_pars),
     ...
     Code => q{
         /* set-up variables I will need throughout the threadloop */
         int alpha;
     } . generate_init_args_for(@func_pars)
       . create_boolean_setters_for(@func_pars)
     . q{
         alpha = -1;
         ... 
         threadloop %{
             ...
         %}
     },

=end details

=cut

sub create_boolean_setters_for {
	# Make sure I handle an empty list correctly. I can't imagine
	# calling this function with an empty list, but let's be safe:
	return '' unless @_;
	# This is the string I will build up for my return value:
	my $to_return = "
		/* The last of the declarations */
		SV* key;
		HV* arg_hash_hv;
		int ";
	# Create the variable list (is_setting_colors, is_setting_lineWidths...):
	$to_return .= join(', ', map {"is_setting_$_"} @_) . ";\n";
	
	# Set the variables:
	$to_return .= "
		/* Begin initializing the values */
		key = sv_newmortal();
		arg_hash_hv = (HV*)SvRV(\$COMP(arg_ref_sv));
";
	foreach(@_) {
		$to_return .= "\t\tsv_setpv(key, \"$_\");\n"
					. "\t\tis_setting_$_ = hv_exists_ent(arg_hash_hv, key, 0);\n";
	}
	return $to_return;
}

####################################
# Creating the initialization code #
####################################

=begin details

I've built up a lot of machinery to handle the various required arguments
and optional properties. This next chunk of code gives a single function
that will call everything in the proper order to declare and initialize
the necessary variables, early within the Code section.

=end details

=cut

sub initialize_for {
	my @properties = @_;
	return '
		/* BEGIN AUTOGENERATED INITIALIZATION */

	' . generate_init_args_for(@properties)
	  . create_boolean_setters_for(@properties) . '
		
		/* END AUTOGENERATED INITIZLIATION */
	';
}

my $default_other_pars = 'SV * arg_ref_sv';

#################################
# Calling the apricot.h setters #
#################################

=begin details

Each of the setters needs to first check if its call is even necessary
(using the boolean variables set-up in the previous section),
and then it needs to call the appropriate setter from apricot.h. This is
easy by repetitive code, so once again I generate it from the same
list of arguments as everything else. In what follows, I create a
function that generates these code fragments for me, or looks them up
in a hash if they're complicated. Note that the function wraps the
looked-up code in its own curly-braced block; all you need to write is
the code itself like the following colors example shows:

The auto-generated code for this section is inserted directly into the
Code key in the pp_def function call, within the threadloop, before the
apricot function for this function is itself called. For example:

 q[
     ...
     threadloop %{
		 /* Apply any per-threadloop tweaks */
         ] . generate_setter_code_for(@func_pars)
         . q[
         /* Call the apricot function */
         apc_gp_set_func(args);
     %}
 ]

=end details

=cut

my %set_code_for = (
	colors => q{
				/* cast the integer as a Colors type (which itself is a
				 * 32-bit int, so maybe this is unnecessary */
				apc_gp_set_color(widget_handle, (Color)$colors());
},
);

sub generate_single_setter_code_for {
	my $property = shift;
	# Make the singular name from the plural:
	(my $singular = $property) =~ s/s$//;
	# apricot uses underscores and all lowercase instead of CamelCase:
	(my $apricot  = $singular) =~ s/([A-Z])/_\l$1/g;
	# Build the return string:
	my $to_return = "\t\t\tif (is_setting_$property) {\n";
	if (exists $set_code_for{$property}) {
		# Insert special handling code:
		$to_return .= $set_code_for{$property};
	}
	else {
		# Most other properties are direct sets:
		$to_return .= "\t\t\t\tapc_gp_set_$apricot(widget_handle, \$$property());\n";
	}
	
	$to_return .= "\t\t\t}";
}

sub generate_setter_code_for {
	return "
			widget_handle = (Handle)\$handles();
			/* BEGIN AUTOGENERATED SETTER CHECKS */\n"
			. join("\n", (map {generate_single_setter_code_for($_)} @_)) . "
			/* END AUTOGENERATED SETTER CHECKS */\n";
}

##################################################
# Building machinery for the different properies #
##################################################

=begin details

Now that I have all of the infrastructure ready, I need to build up the
data structures for each of the properties.

=end details

=cut

# Background color:
$pars_args_for{backColors} = 'int backColors()';
$set_code_for{backColors} = q{
				/* cast the integer as a Colors type (actually an int) */
				apc_gp_set_back_color(widget_handle, (Color)$backColors());
};

# Clipping rectangle:
$pars_args_for{clipRects} = 'int clipLeft(); int clipBottom(); int clipRight(); int clipTop()';
$init_args_for{clipRects} = 'Rect clip_rect';
$set_code_for{clipRects} = q{
				clip_rect.left = $clipLeft();
				clip_rect.bottom = $clipBottom();
				clip_rect.right = $clipRight();
				clip_rect.top = $clipTop();
				apc_gp_set_clip_rect(widget_handle, clip_rect);
};

# These do no need any special args, and the default generated code will
# work just fine:
$pars_args_for{lineEnds} = 'int lineEnds()';
$pars_args_for{lineJoins} = 'int lineJoins()';
$pars_args_for{lineWidths} = 'int lineWidths()';
$pars_args_for{rops} = 'int rops()';
$pars_args_for{rop2s} = 'int rop2s()';

# line patterns. This code has to cast the byte piddle into a char and
# send that and the length to the line_pattern function.
$pars_args_for{linePatterns} = 'byte linePatterns(patlen)';
$init_args_for{linePatterns} = 'unsigned char * pattern; int pattern_length';
$set_code_for{linePatterns} = q{
				pattern = (unsigned char *)$P(linePatterns);
				pattern_length = strlen(pattern);
				apc_gp_set_line_pattern(widget_handle, pattern, pattern_length);
};

# translation; the apricot function for translate uses a different name
# and takes two arguments instead of one:
$pars_args_for{translates} = 'int trans_x(); int trans_y()';
$set_code_for{translates} = q{
				/* invoke the apricot function with both x and y */
				apc_gp_set_transform(widget_handle, $trans_x(), $trans_y());
};

# Fill winding works nicely without any alteration:
$pars_args_for{fillWindings} = 'int fillWindings()';

# Fill pattern will may work nicely without any alteration, but I am
# going to be explicit and cast the fillPattern piddle into a U8 array:
$pars_args_for{fillPatterns} = 'byte fillPatterns(oct=8)';
$set_code_for{fillPatterns} = q{
			/* Casts the pattern as a U8 pointer and continues */
			apc_gp_set_fill_pattern(widget_handle, (U8*)$P(fillPatterns));
};

# Spline precision works well with the default setup:
$pars_args_for{splinePrecisions} = 'int splinePrecisions()';

# Ignoring for now: region
# The underlying graphics functions explicitly operate with a 1-bit-per-pixel
# Prima::Image bitmap. I could use PDL::PrimaImage as the argument, but
# that seems like a lot of repackaging for every round in the PP
# threadloop. Alternatively, I could take an array ref with Prima::Image
# objects as the argument, and simply cycle through that.


#######################################################
# Argument processing, ordering, and default handling #
#######################################################

=begin details

Each of the perl-side functions that gets invoked as an object
method checks its arguments. It does this by analyzing the hash sent in
by the caller, checking for properties that don't belong, or were
mis-spelled, and repackaging the results into a list with the exact
order needed by the PP code. Most parameters take a single piddle as
their argument, but some don't. This code needs to know how many
arguments go with each parameter, so it can check that, too. Such a list
of parameters can be automatically constructed from the already-defined
%pars_args_for hash.

=end details

=cut

pp_addpm (join("\n"
	, '# This is a list of the number of arguments for each property. It is based on the'
	, '# pars_args_for hash which is built in the .pd file associated with this module'
	, 'my %N_args_for = qw('
	# Note that the tr operator, as used, just counts the number of semi-colons
	# in the pars args associated with the property.
	, (map {sprintf "\t%-20s %d", $_, ($pars_args_for{$_} =~ tr/;//) + 1}
		(keys %pars_args_for))
	, ');'
	)
);

=begin details

Having collected the number of arguments associated with each of the
properties, I need a function to actually process the hash.
This is a function that I call in all of my PMCode sections. It takes an
anonymous list of names and an anonymous hash. If the hash has a key for
one of the names, it includes that in the return list. If it doesn't, it
returns the default value of a 0-dim piddle with value 0. If one of the
hash keys is not in the list of names, it croaks.

Put a little differently, this function takes an anonymous hash, makes
sure there are no extraneous arguments, extracts the desired arguments
or uses a sensible default, and returns the arguments in the desired
order.

=end details

=cut

pp_addpm <<'DefaultArgumentHandling';

sub get_sorted_args_with_defaults {
	my ($self, $arg_names, $given) = @_;
	
	# Default to an empty list:
	$given = {} unless ref($given) eq 'HASH';
	
	# Copy the arg_names array, so I can add 'handles' to it without
	# effecting the original array:
	my @arg_names = @$arg_names;
	unshift @arg_names, 'handles';
	
	# Check that they supplied only allowed parameters:
	foreach (keys %$given) {
		croak("Unknown parameter $_") unless $_ ~~ @$arg_names
	}
	
	# Create a 0-dim piddle with this object's hande in it:
	my $handle = piddle_of_handles_for($self);
	
	# Return the sorted list of supplied or default values
	my @to_return = ();
	foreach ('handles', @$arg_names) {
		# If not specified, return a default property of a zero-dim
		# piddle. Except for the handles, the value doesn't matter
		# because it is never used. For handles, the value should revert
		# to the calling widget's handle:
		if (not exists $given->{$_}) {
			push @to_return, $handle;
		}
		elsif (ref ($given->{$_}) eq 'ARRAY') {
			# If an array ref, dereference it and make sure the number
			# of arguments agrees with what we expect:
			if (@{$given->{$_}} != $N_args_for{$_}) {
				croak("Expected 1 argument for $_") if $N_args_for{$_} == 1;
				croak("Expected $N_args_for{$_} arguments for $_");
			}
			push @to_return, @{$given->{$_}};
		}
		else {
			# Otherwise, return it outright, if we only expected one
			# argument:
			$N_args_for{$_} == 1
				or croak("Expected $N_args_for{$_} arguments for $_");
			
			push @to_return, $given->{$_};
		}
	}
	return @to_return;
}

DefaultArgumentHandling


###################################
# Generating PMCode automatically #
###################################

=begin details

The PMCode section of each of these is pretty much the same. This
snippet of code generates that code for me. It takes the names of the
arguments and returns the autogenerate PMCode.

This code is very dense. I hope that it is documented well enough with
comments that any future maintainer will be able to understand it. If
in doubt, this function operates stand-alone, so you can copy it into
a little test script and try calling it with sample parameters to get a
feel for how it behaves.

working here - I have a few argument checking
ideas for this function, including
considering checking that C<$self> is a Prima::Drawable type, but not
Prima::PS::Drawable. Also, I bet if PDL barfs, it'll point to the line
in the (generated) pm file, so the pdl function call should probably be
wrapped in an eval block, and $@ should be post-processed.

=end details

=cut

sub generate_PMCode_for {
	my ($func_name, $props, @arg_names) = @_;
	my $props_array_name = '@' . $func_name . '_props';
	my $args_array_name = '@' . $func_name . '_args';
	# Outside the function definition, create the list of properties
	# that this function uses, as well as the names of the arguments.
	# It needs these lists in the actual Perl module file so it can
	# check the passed arguments and provide meaningful error messages:
	my $to_return = "my $props_array_name = qw(@$props);\n"
				. "my $args_array_name = qw(@arg_names);\n";
	
	# Define the drawable function in the Prima::Drawable namespace
	# and check for arguments:
	$to_return .= "sub Prima::Drawable::pdl_$func_name {
	# Before anything else, make sure they supplied at least the
	# required number of arguments:
	croak('pdl_$func_name expectes '. scalar($args_array_name)
		. ' arguments (and the widget): ' . join(', ', 'widget', $args_array_name))
		unless (\@_ > $args_array_name);

	# unpack the widget and the required arguments for this function:
";
	foreach ('self', @arg_names) {
			$to_return .= "\tmy \$$_ = shift;\n";
	}
	$to_return .= "
	# Check for an even number of remaining arguments (key-value pairs):
	croak('pdl_$func_name expects optional parameters ans key => value pairs')
		unless \@_ % 2 == 0;	# *strictly* greater accounts for \$self
	
	my \%args = \@_;
	
	# Get the a full list of arguments suitable for the internal pp code
	# in the correct order:
	my \@args_with_defs
		= get_sorted_args_with_defaults(\$self, \\$props_array_name, \\\%args);

	# Call the PP'd internal code. Always put self and the args hash
	# last.
	eval {
		PDL::_prima_${func_name}_int(";
	# include all the required arguments:
	foreach(@arg_names) {
		$to_return .= '$' . $_ . ', ';
	}
	# finish with self and the args list:
	$to_return .= '@args_with_defs, \%args);
	};
	
	if ($@) {
		# die $@;
		$@ =~ s/at (.*?) line \d+\.\n$//;
		die "Issues calling pdl_' . $func_name . ': $@";
	}
	' . "\n}\n";
	 
	return $to_return;
}


#######################################################################
#                              Functions                              #
#######################################################################

=begin details

At last I begin the declaration of PP code. The idea behind all of this
machinary is that I declare a collection of applicable properties in
THIS SCRIPT, and then use that to generate consistent code blocks

=end details

=cut

##############
# prima_arcs #
##############

my @properties = qw(colors backColors lineEnds linePatterns lineWidths rops rop2s);
pp_def('prima_arcs',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('arcs', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for arcs, so I'll just add the
	# auto-generated declaration and initialiation code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_arc(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => <<'EOD'

=head2 arcs

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters. The
difference between this command and L<chords> is that this command does
not connect the ends of the arcs with straight lines but leaves the
arcs open

=for example

 working here

=cut

EOD
);

##############
# prima_bars #
##############

@properties = qw(colors backColors fillPatterns rops rop2s);
pp_def('prima_bars',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('bars', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialiation code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's bar function */
			apc_gp_bar(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => <<'EOD'

=head2 bars

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws filled rectangle from corner (x1, y1) to (x2, y2).

=for example

 working here

=cut

EOD
);

################
# prima_chords #
################

@properties = qw(colors backColors lineEnds linePatterns lineWidths rops rop2s);
pp_def('prima_chords',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('chords', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for chords, so I'll just add the
	# auto-generated declaration and initialiation code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's chord function */
			apc_gp_chord(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => <<'EOD'

=head2 chords

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters, and connects
the ends with a straight line. The difference between this command and
arcs is that it connects the ends.

=for example

 working here

=cut

EOD
);

##################
# prima_ellipses #
##################

@properties = qw(colors backColors linePatterns lineWidths rops rop2s);
pp_def('prima_ellipses',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();'
			. generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('ellipses', \@properties, qw(x y x_diameter y_diameter)),
	Code => 
	# I don't need any extra variables for ellipses, so I'll just add the
	# auto-generated declaration and initialiation code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's ellipse function */
			apc_gp_ellipse(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter());
		%}
	],
	Doc => <<'EOD'

=head2 ellipses

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters.

=for example

 working here

=cut

EOD
);

#####################
# prima_fill_chords #
#####################

@properties = qw(colors backColors linePatterns lineWidths rops rop2s);
pp_def('prima_fill_chords',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('fill_chords', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for chords, filled or otherwise,
	# so I'll just add the auto-generated declaration and initialiation
	# code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's fill_chord function */
			apc_gp_fill_chord(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => <<'EOD'

=head2 fill_chords

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters.

=for example

 working here

=cut

EOD
);

#######################
# prima_fill_ellipses #
#######################

@properties = qw(colors backColors linePatterns lineWidths rops rop2s);
pp_def('prima_fill_ellipses',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('fill_ellipses', \@properties, qw(x y x_diameter y_diameter)),
	Code => 
	# I don't need any extra variables for ellipses, filled or otherwise,
	# so I'll just add the auto-generated declaration and initialiation
	# code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's fill_ellipse function */
			apc_gp_fill_ellipse(widget_handle, $x(), $y(), $x_diameter(), $y_diameter());
		%}
	],
	Doc => <<'EOD'

=head2 fill_ellipses

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); properties)

=for ref

Draws a filled ellipse centered at C<x>, C<y>, each with their specified
diameters.

=for example

 working here

=cut

EOD
);


# working here - get the other functions between fill_ellipses and
# lines




###############
# prima_lines #
###############

@properties = qw(colors backColors linePatterns lineWidths rops rop2s);
pp_def('prima_lines',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('lines', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialiation code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's lines function */
			apc_gp_line(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => <<'EOD'

=head2 lines

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws a line from (x1, y1) to (x2, y2).

=for example

 working here

=cut

EOD
);

################
# prima_pixels #
################

@properties = qw(colors);
pp_def('prima_pixels',
	Pars => 'int x(); int y(); int [o] color(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('pixels', \@properties, qw(x y color)),
	Code => 
	# I don't need any extra variables for pixels, so I'll just add the
	# auto-generated declaration and initialiation code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q{
		threadloop %{
			/* Unlike usual, I will not use the setter code. Rather,
			 * the is_setting_colors will determine whether or not I
			 * set the pixel:
			 */
			if (is_setting_colors) {
				apc_gp_set_pixel(widget_handle, $x(), $y(), (Color)$colors());
			}
			
			/* No matter what, get the previous color. NOTE that the
			 * retrieved results goes in color (singular), not colors
			 */
			$color() = (PDL_Long) apc_gp_get_pixel(widget_handle, $x(), $y());
		%}
	},
	Doc => <<'EOD'

=head2 lines

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws a line from (x1, y1) to (x2, y2).

=for example

 working here

=cut

EOD
);

###################
# prima_polylines #
###################

@properties = qw(colors backColors linePatterns lineWidths lineJoins
						lineEnds rops rop2s);
pp_def('prima_polylines',
	Pars => 'x(n); y(n); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('polylines', \@properties, qw(x y)),
	Code => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialiation code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs and nans gracefully by treating the same
			 * way as I would bad values.
			 */
			for(i = 0; i < n_size; /* no action */) {
				for(n_to_plot = 0; n_to_plot + i < n_size; n_to_plot++) {
					int total_offset = n_to_plot + i;
					xval = $x(n => total_offset);
					yval = $y(n => total_offset);
					
					/* Finish this segment if we encounte nan */
					if (xval != xval || yval != yval) {		/* nan check */
						/* increment i so that it skips this value on
						 * the next round
						 */
						i++;
						break;
					}
					else {
						/* handle infinities */
						if (xval == xval + 1) {
							if (xval < 0)
								xval = -ONE_MILLION;
							else
								xval = ONE_MILLION;
						}
						if (yval == yval + 1) {
							if (yval < 0)
								yval = -ONE_MILLION;
							else
								yval = ONE_MILLION;
						}
						
						to_plot[n_to_plot].x = xval;
						to_plot[n_to_plot].y = yval;
					}
				}
				/* Call apricot's polyline function */
				if (n_to_plot > 1)
					apc_gp_draw_poly(widget_handle, n_to_plot, to_plot);
				
				/* Keep track of the starting position */
				i += n_to_plot;
			}
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	HandleBad => 1,
	BadCode => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialiation code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs and nans gracefully by treating the same
			 * way as I would bad values.
			 */
			for(i = 0; i < n_size; /* no action */) {
				for(n_to_plot = 0; n_to_plot + i < n_size; n_to_plot++) {
					/* Get the values from the array */
					int total_offset = n_to_plot + i;
					xval = $x(n => total_offset);
					yval = $y(n => total_offset);
					
					/* finish this segment if we encounter nan or a bad value */
					if (xval != xval || yval != yval		/* nan check */
						|| $ISBAD(x(n => total_offset))		/* bad value */
						|| $ISBAD(y(n => total_offset))) {	/* checks    */
						/* increment i so that it skips this value on
						 * the next round
						 */
						i++;
						break;
					}
					else {
						/* handle infinities */
						if (xval == xval + 1) {
							if (xval < 0)
								xval = -ONE_MILLION;
							else
								xval = ONE_MILLION;
						}
						if (yval == yval + 1) {
							if (yval < 0)
								yval = -ONE_MILLION;
							else
								yval = ONE_MILLION;
						}
						
						to_plot[n_to_plot].x = xval;
						to_plot[n_to_plot].y = yval;
					}
				}
				/* Call apricot's polyline function */
				if (n_to_plot > 1)
					apc_gp_draw_poly(widget_handle, n_to_plot, to_plot);
				
				/* Keep track of the starting position */
				i += n_to_plot;
			}
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	Doc => <<'EOD'

=head2 polylines

 working here:
  Prima Signature: (widget; x(n); y(n); properties)

=for ref

Draws a multi-segment line on a widget with the given x- and y-coordinates.

This is useful for making line-drawings, such as plotting data.

Applicable properties include colors backColors linePatterns lineWidths
lineJoins lineEnds rops rop2s

=for example

 # Draw a sine curve on the widget:
 my $x = sequence(200);
 my $y = ( sin($x / 20) + 1 ) * 50;
 $widget->pdl_polyline($x, $y);

=cut

EOD
);






pp_addpm({At=>'Bot'},<<'EOD');

=head1 ERROR MESSAGE

This function may throw the following exception:

=head2 Your widget must be derived from Prima::Drawable

This means that you tried to draw on something that is not a Prima::Drawable
object, or a class derived from it. I don't know enough about the Prima
internals to know if that has any hope of working, but why do it in the first
place?

=head1 TODO

These are all the things I wish to do:

=over

=item Full Drawabel API

I would like a PDL function for every drawable function in the API.

=item PS Functionality

Currently, this library only implements PDL functions using the apricot
library. Since L<Prima::PS::Drawable> implements its own drawing
functions, none of the PDL drawing functions will work.
They need their own specially created functions that will emit postscript
code. That may prove challenging, and will likely require a seperate
interface with a reduced number of optional properties.

=item Bad Value Support

PLplot's bindings have a very sensible interpretation for bad values: they are
omitted. This should be replicated in this library.

=item Full Options Support

I want to take PDL arrays for all of the drawing options, especially color and
line thickness. This way, one could draw 15 lines with 15 different colors and
thicknesses simply by specifying thickness and color piddles.

=back

=head1 AUTHOR

David Mertens, E<lt>dcmertens.perl@gmail.comE<gt>.

=head1 SEE ALSO

The Perl Data Language, L<PDL>

The Prima toolkit, http://www.prima.eu.org/, L<Prima>

Since this amounts to a plotting package, you should check out other plotting
packages available for PDL. Two notable examples are L<PDL::Graphics::PLplot>
and L<PDL::Graphics::PGPLOT>.

Another interface between PDL and Prima is <PDL::PrimaImage>. I am indebted to
Dmitry for that module because it gave me a working template for this module,
including a working Makefile.PL. Thanks Dmitry!

=cut

EOD

pp_export_nothing();
pp_done();
